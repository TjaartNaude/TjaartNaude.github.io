import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/persisted-state-vuex/dist/constants/storage.constants.js
var require_storage_constants = __commonJS({
  "node_modules/persisted-state-vuex/dist/constants/storage.constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STORAGE_KEY = void 0;
    exports.STORAGE_KEY = "vuex";
  }
});

// node_modules/persisted-state-vuex/dist/config/index.js
var require_config = __commonJS({
  "node_modules/persisted-state-vuex/dist/config/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStorageKey = void 0;
    var storage_constants_1 = require_storage_constants();
    var getStorageKey = (options) => {
      return options.storageKey ? String(options.storageKey) : storage_constants_1.STORAGE_KEY;
    };
    exports.getStorageKey = getStorageKey;
  }
});

// node_modules/persisted-state-vuex/dist/plugins/storage-limit-control.js
var require_storage_limit_control = __commonJS({
  "node_modules/persisted-state-vuex/dist/plugins/storage-limit-control.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageLimitControl = void 0;
    var storageLimit = 5242878;
    var storageLimitControl = (valueToAdd) => __awaiter(void 0, void 0, void 0, function* () {
      const storage = window === null || window === void 0 ? void 0 : window.localStorage;
      let concatenatedString = valueToAdd;
      if (storage) {
        yield Promise.all(Object.values(storage).map((val) => {
          concatenatedString += val;
        }));
      }
      return concatenatedString.length < storageLimit;
    });
    exports.storageLimitControl = storageLimitControl;
  }
});

// node_modules/persisted-state-vuex/dist/utils/browser-control.utils.js
var require_browser_control_utils = __commonJS({
  "node_modules/persisted-state-vuex/dist/utils/browser-control.utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isOnClient = void 0;
    var isOnClient = () => {
      if (typeof window !== "undefined") {
        return true;
      } else {
        return false;
      }
    };
    exports.isOnClient = isOnClient;
  }
});

// node_modules/persisted-state-vuex/dist/app.js
var require_app = __commonJS({
  "node_modules/persisted-state-vuex/dist/app.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var config_1 = require_config();
    var storage_limit_control_1 = require_storage_limit_control();
    var browser_control_utils_1 = require_browser_control_utils();
    var options = {};
    exports.default = {
      config: (configOptions) => {
        if (configOptions) {
          options = configOptions;
        }
      },
      init: (store) => {
        if ((0, browser_control_utils_1.isOnClient)()) {
          const storage = window === null || window === void 0 ? void 0 : window.localStorage;
          const setStorage = (payload) => __awaiter(void 0, void 0, void 0, function* () {
            const isBelowLimit = yield (0, storage_limit_control_1.storageLimitControl)(String(payload));
            if (isBelowLimit) {
              storage.setItem((0, config_1.getStorageKey)(options), JSON.stringify(payload));
            }
          });
          const removeStorage = () => {
            storage.removeItem((0, config_1.getStorageKey)(options));
          };
          const getStorage = () => {
            return JSON.parse(storage.getItem((0, config_1.getStorageKey)(options)));
          };
          const replaceState = () => {
            const storedState = getStorage();
            if (storedState && typeof storedState === "object") {
              if (options.paths) {
                const filteredState = store.state;
                options.paths.forEach((module2, key) => {
                  var _a;
                  filteredState[module2] = storedState[module2];
                  if (((_a = options.paths) === null || _a === void 0 ? void 0 : _a.length) === key + 1) {
                    store.replaceState(filteredState);
                  }
                });
                return;
              }
              store.replaceState(storedState);
            }
          };
          store.subscribe((_, state) => {
            removeStorage();
            if (options.paths) {
              const payload = {};
              options.paths.forEach((module2, key) => {
                var _a;
                payload[module2] = state[module2];
                if (((_a = options.paths) === null || _a === void 0 ? void 0 : _a.length) === key + 1) {
                  setStorage(payload);
                }
              });
              return;
            }
            setStorage(state);
          });
          replaceState();
        }
      }
    };
  }
});

// dep:persisted-state-vuex
var persisted_state_vuex_default = require_app();
export {
  persisted_state_vuex_default as default
};
//# sourceMappingURL=persisted-state-vuex.js.map
